stages:
  - build
  - test
  - publish
  - qa

default:
  image: registry.gitlab.com/gitlab-org/gitlab-build-images:ruby-2.7-golang-1.16-git-2.31
  tags:
    - gitlab-org

variables:
  DOCKER_DRIVER: overlay2
  SAST_DISABLE_DIND: "true"
  SAST_DEFAULT_ANALYZERS: "gosec"
  # We use Gitaly's Git version by default.
  GIT_VERSION: "default"
  GO_VERSION: "1.17"
  RUBY_VERSION: "2.7"
  POSTGRES_VERSION: "12.6-alpine"

include:
  - template: Workflows/MergeRequest-Pipelines.gitlab-ci.yml
  - template: Security/License-Scanning.gitlab-ci.yml
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml
  - template: Security/Coverage-Fuzzing.gitlab-ci.yml
  - template: Security/Secret-Detection.gitlab-ci.yml

.cache: &cache_definition
  cache: &cache_configuration
    key:
      files:
        - Makefile
        - ruby/Gemfile.lock
      prefix: git-${GIT_VERSION}-ruby-${RUBY_VERSION}
    paths:
      - _build/deps
      - ruby/vendor/bundle
    policy: pull

.test_template: &test_definition
  <<: *cache_definition
  stage: test
  artifacts:
    paths:
    - ruby/tmp/gitaly-rspec-test.log
    when: on_failure
    expire_in: 1 week

.postgres_template: &postgres_definition
  image: registry.gitlab.com/gitlab-org/gitlab-build-images:ruby-${RUBY_VERSION}-golang-${GO_VERSION}-git-2.31
  services:
    - postgres:${POSTGRES_VERSION}
  variables: &postgres_variables
    PGHOST: postgres
    PGPORT: "5432"
    PGUSER: postgres
    POSTGRES_HOST_AUTH_METHOD: trust
  before_script:
    - go version
    - git version
    - while ! psql -h $PGHOST -U $PGUSER -c 'SELECT 1' > /dev/null; do echo "awaiting Postgres service to be ready..." && sleep 1 ; done && echo "Postgres service is ready!"

.pgbouncer_template: &pgbouncer_definition
  <<: *postgres_definition
  image: registry.gitlab.com/gitlab-org/gitlab-build-images:ruby-${RUBY_VERSION}-golang-${GO_VERSION}-git-2.31-pgbouncer-1.14
  variables:
    <<: *postgres_variables
    PGHOST_PGBOUNCER: 0.0.0.0
    PGPORT_PGBOUNCER: "6432"
  before_script:
    - go version
    - git version
    - pgbouncer --version
    - adduser --no-create-home --disabled-password --disabled-login --quiet --force-badname --gecos '' pgbouncer-runner
    - su pgbouncer-runner -c 'pgbouncer internal/praefect/datastore/glsql/testdata/pgbouncer.ini' &
    - for i in {1..10}; do psql -U $PGUSER -c 'select now()' && break; done || { echo 'pgbouncer awaiting failed' ; exit 1; }

danger-review:
  image: ruby:2.7
  allow_failure: true
  stage: build
  only:
    - merge_requests
  except:
    - tags
    - master
  variables:
    BUNDLE_GEMFILE: danger/Gemfile
  before_script:
    - bundle install
  script:
    - >
      if [ -z "$DANGER_GITLAB_API_TOKEN" ]; then
        # Force danger to skip CI source GitLab and fallback to "local only git repo".
        unset GITLAB_CI
        # We need access to the base SHA to help danger determine the base commit for this shallow clone.
        bundle exec danger dry_run --fail-on-errors=true --verbose --base='$CI_MERGE_REQUEST_DIFF_BASE_SHA'
      else
        bundle exec danger --fail-on-errors=true --verbose
      fi

build:
  stage: build
  image: registry.gitlab.com/gitlab-org/gitlab-build-images:ruby-${RUBY_VERSION}-golang-${GO_VERSION}-git-2.31
  cache:
    <<: *cache_configuration
    policy: pull-push
  script:
    - go version
    - make all git
    - _support/test-boot .
  parallel:
    matrix:
      # These definitions are for the non-default Git versions.
      #- GO_VERSION: [ "1.16", "1.17" ]
      #  GIT_VERSION: [ ]
      # These definitions are for the default Git version where we want to
      # apply our default set of Git patches.
      - GO_VERSION: [ "1.16", "1.17" ]

build:binaries:
  <<: *cache_definition
  stage: build
  image: registry.gitlab.com/gitlab-org/gitlab-build-images:ruby-${RUBY_VERSION}-golang-${GO_VERSION}-git-2.31
  only:
    - tags
  script:
    # Just in case we start running CI builds on other architectures in future
    - go version
    - make build
    - cd _build && sha256sum bin/* | tee checksums.sha256.txt
  artifacts:
    paths:
    - _build/checksums.sha256.txt
    - _build/bin/
    name: "${CI_JOB_NAME}:go-${GO_VERSION}-git-${GIT_VERSION}"
    expire_in: 6 months
  parallel:
    matrix:
      - GO_VERSION: [ "1.16", "1.17" ]

proto:
  <<: *cache_definition
  stage: test
  script:
    - make proto no-changes
  artifacts:
    paths:
    - _build/proto.diff
    - ruby/proto/gitaly/*
    - proto/go/gitalypb/*
    when: on_failure

test:
  <<: *test_definition
  <<: *postgres_definition
  image: registry.gitlab.com/gitlab-org/gitlab-build-images:ruby-${RUBY_VERSION}-golang-${GO_VERSION}-git-2.31
  script:
    - _build/deps/git/install/bin/git version
    # This command will make all directories except of our build directory and Ruby code unwritable.
    # The purpose is to verify that there is no test which writes into those directories anymore, as
    # they should all instead use a temporary directory for runtime data.
    - find . -type d \( -path ./_build -o -path ./ruby \) -prune -o -type d -exec chmod a-w {} \;
    - make ${TARGET}
  artifacts:
    paths:
      - _build/reports/go-tests-report-go-${GO_VERSION}-git-${GIT_VERSION}.xml
    reports:
      junit: _build/reports/go-tests-report-go-${GO_VERSION}-git-${GIT_VERSION}.xml
  parallel:
    matrix:
      # These definitions are for the non-default Git versions.
      #- GO_VERSION: [ "1.16", "1.17" ]
      #  GIT_VERSION: [ ]
      #  TARGET: test
      # These definitions are for the default Git version where we want to
      # apply our default set of Git patches.
      - GO_VERSION: [ "1.16", "1.17" ]
        TARGET: test
      - TARGET: [ test-with-proxies, test-with-praefect, race-go ]
      # Execute tests with our minimum required Postgres version, as well. If
      # the minimum version changes, please change this to the new minimum
      # version. Furthermore, please make sure to update the minimum required
      # version in `datastore.CheckPostgresVersion()`.
      - POSTGRES_VERSION: "11.14-alpine"
        TARGET: [ test, test-with-praefect ]

test:coverage:
  <<: *cache_definition
  <<: *postgres_definition
  stage: test
  script:
    - make cover
  artifacts:
    reports:
      cobertura: _build/cover/cobertura.xml

test:pgbouncer:
  # This job verifies all operations run without issues if PgBouncer is set in between service and PostgreSQL database.
  <<: *test_definition
  <<: *pgbouncer_definition
  script:
    - make test-postgres

test:nightly:
  <<: *test_definition
  <<: *postgres_definition
  image: registry.gitlab.com/gitlab-org/gitlab-build-images:ruby-${RUBY_VERSION}-golang-${GO_VERSION}-git-2.31
  script:
    - go version
    - make all ${TARGET}
  parallel:
    matrix:
      - GIT_VERSION: [ "master", "next" ]
        TARGET: [ test, test-with-proxies, test-with-praefect ]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'

test:praefect_smoke:
  <<: *test_definition
  services:
    - postgres:${POSTGRES_VERSION}
  variables:
    POSTGRES_DB: praefect_test
    POSTGRES_USER: praefect
    POSTGRES_PASSWORD: sql-password
  script:
    - make
    # Sanity check: direct ping with psql
    - PGPASSWORD=$POSTGRES_PASSWORD psql -h postgres -U $POSTGRES_USER -d $POSTGRES_DB -c 'select now()'
    - ruby -rerb -e 'ERB.new(ARGF.read).run' _support/config.praefect.toml.ci-sql-test.erb > config.praefect.toml
    - ./_build/bin/praefect -config config.praefect.toml sql-ping
    - ./_build/bin/praefect -config config.praefect.toml sql-migrate

test:fuzz_objectinfo:
  extends: .fuzz_base
  stage: test
  script:
    - apt update && apt install -y clang-7
    - go get github.com/dvyukov/go-fuzz/go-fuzz && go get github.com/dvyukov/go-fuzz/go-fuzz-build
    - /root/go/bin/go-fuzz-build -libfuzzer -o objectinfo_fuzzer.a ./internal/git/catfile
    - clang-7 -fsanitize=fuzzer objectinfo_fuzzer.a -o objectinfo_fuzzer
    - ./gitlab-cov-fuzz run -- ./objectinfo_fuzzer -max_total_time=300

verify:
  <<: *cache_definition
  stage: test
  script:
    - make verify

lint:
  stage: test
  retry: 2
  script:
    - go version
    - make lint

gosec-sast:
  before_script:
    - apk add pkgconfig libgit2-dev gcc libc-dev
  rules:
    - if: $SAST_DISABLED
      when: never
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_IID
    - if: $CI_COMMIT_TAG

license_scanning:
  before_script:
    - sudo apt-get update
    - sudo apt-get install -y libicu-dev libgit2-dev cmake
  rules:
    - if: $LICENSE_SCANNING_DISABLED
      when: never
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_IID
    - if: $CI_COMMIT_TAG
  variables:
    LICENSE_FINDER_CLI_OPTS: '--aggregate-paths=. ruby'

gemnasium-dependency_scanning:
  rules:
    - if: $DEPENDENCY_SCANNING_DISABLED
      when: never
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_IID
    - if: $CI_COMMIT_TAG

secret_detection:
  inherit:
    default: false
  rules:
    - if: $SECRET_DETECTION_DISABLED
      when: never
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_IID
    - if: $CI_COMMIT_TAG

trigger-qa:
  stage: qa
  trigger:
    project: gitlab-org/build/omnibus-gitlab-mirror
  variables:
    ALTERNATIVE_SOURCES: "true"
    GITALY_SERVER_VERSION: $CI_COMMIT_SHA
    GITALY_SERVER_ALTERNATIVE_REPO: $CI_PROJECT_URL
    ee: "true"
  rules:
    - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_SHA != ""
      when: manual
      allow_failure: true
      variables:
        # Downstream pipeline does not fetch the merged result SHA.
        # Fix: https://gitlab.com/gitlab-org/omnibus-gitlab/-/issues/6482
        GITALY_SERVER_VERSION: $CI_MERGE_REQUEST_SOURCE_BRANCH_SHA
    - when: manual
      allow_failure: true
